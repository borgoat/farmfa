// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// AddToc defines model for AddToc.
type AddToc struct {

	// A Toc is a "piece" in which a TOTP secret gets split.
	Toc *Toc `json:"toc,omitempty"`
}

// Error defines model for Error.
type Error struct {
	Code    string `json:"code"`
	Message string `json:"message"`
}

// NewSession defines model for NewSession.
type NewSession struct {

	// A first Toc owned by the applicant
	TocZero string `json:"toc_zero"`

	// Seconds until the TOTP generation endpoint expires, starting from the first TOTP generated.
	Ttl *int `json:"ttl,omitempty"`
}

// OracleResponse defines model for OracleResponse.
type OracleResponse interface{}

// Session defines model for Session.
type Session struct {

	// True when enough Tocs have been provided and TOTPs may be generated
	Complete *bool `json:"complete,omitempty"`

	// The time when the session started
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// When the sessions will expire and no longer accept Tocs
	ExpiresAt *time.Time `json:"expires_at,omitempty"`

	// The identifier of a session
	Id *string `json:"id,omitempty"`

	// An identifier for the group of Tocs used in this session
	TocGroupId *string `json:"toc_group_id,omitempty"`

	// The total number of Tocs in the group
	TocsInGroup *int `json:"tocs_in_group,omitempty"`

	// The number of Tocs already provided by consituents to the oracle for this session
	TocsProvided *int `json:"tocs_provided,omitempty"`

	// The minimum number of Tocs required
	TocsThreshold *int `json:"tocs_threshold,omitempty"`

	// Seconds until the TOTP generation endpoint expires, starting from the first token generated.
	Ttl *int `json:"ttl,omitempty"`
}

// SessionCredentials defines model for SessionCredentials.
type SessionCredentials struct {
	// Embedded struct due to allOf(#/components/schemas/Session)
	Session `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/SessionPublicKey)
	SessionPublicKey `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/SessionPrivateKey)
	SessionPrivateKey `yaml:",inline"`
}

// SessionPrivateKey defines model for SessionPrivateKey.
type SessionPrivateKey struct {

	// A part of a private key (the other half is kept by the oracle) used to decrypt Tocs given by constituents. This part of private key must be kept by the applicant, so that it may be given to the oracle, when requesting a TOTP to be generated.
	PrivateKey *string `json:"private_key,omitempty"`
}

// SessionPublicKey defines model for SessionPublicKey.
type SessionPublicKey struct {

	// A public key used by constituents to encrypt their Tocs before sharing them with the oracle. The applicant receives it when creating a sessions, and must share it with constituents when requesting their approval.
	PublicKey *string `json:"public_key,omitempty"`
}

// TOTPCode defines model for TOTPCode.
type TOTPCode struct {

	// The time when this session will expire and cannot be called again
	SessionExpiresAt *time.Time `json:"session_expires_at,omitempty"`

	// The current TOTP
	Totp *string `json:"totp,omitempty"`

	// The time when the current TOTP will expire
	TotpExpiresAt *time.Time `json:"totp_expires_at,omitempty"`
}

// Toc defines model for Toc.
type Toc struct {

	// Each Toc is part of a group. Tocs from the same group can reconstruct a secret
	GroupId *string `json:"group_id,omitempty"`

	// The number of Tocs in the group
	GroupSize *int `json:"group_size,omitempty"`

	// The nubmer of Tocs needed to reconstruct the secret
	GroupThreshold *int `json:"group_threshold,omitempty"`

	// Free-text to describe the purpose of a Toc
	Note *string `json:"note,omitempty"`

	// The actual share that players should keep secret
	Share *string `json:"share,omitempty"`

	// A Toc is unique, this ID ensures a Toc is not reused
	TocId *string `json:"toc_id,omitempty"`
}

// DefaultError defines model for DefaultError.
type DefaultError Error

// CreateSessionJSONBody defines parameters for CreateSession.
type CreateSessionJSONBody NewSession

// PostTocJSONBody defines parameters for PostToc.
type PostTocJSONBody AddToc

// GenerateTotpJSONBody defines parameters for GenerateTotp.
type GenerateTotpJSONBody SessionPrivateKey

// CreateSessionJSONRequestBody defines body for CreateSession for application/json ContentType.
type CreateSessionJSONRequestBody CreateSessionJSONBody

// PostTocJSONRequestBody defines body for PostToc for application/json ContentType.
type PostTocJSONRequestBody PostTocJSONBody

// GenerateTotpJSONRequestBody defines body for GenerateTotp for application/json ContentType.
type GenerateTotpJSONRequestBody GenerateTotpJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = http.DefaultClient
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// CreateSession request  with any body
	CreateSessionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSession(ctx context.Context, body CreateSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSession request
	GetSession(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostToc request  with any body
	PostTocWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostToc(ctx context.Context, id string, body PostTocJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateTotp request  with any body
	GenerateTotpWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateTotp(ctx context.Context, id string, body GenerateTotpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) CreateSessionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSessionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSession(ctx context.Context, body CreateSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSessionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSession(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSessionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTocWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTocRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostToc(ctx context.Context, id string, body PostTocJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTocRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateTotpWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateTotpRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateTotp(ctx context.Context, id string, body GenerateTotpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateTotpRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCreateSessionRequest calls the generic CreateSession builder with application/json body
func NewCreateSessionRequest(server string, body CreateSessionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSessionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSessionRequestWithBody generates requests for CreateSession with any type of body
func NewCreateSessionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/sessions")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSessionRequest generates requests for GetSession
func NewGetSessionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/sessions/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostTocRequest calls the generic PostToc builder with application/json body
func NewPostTocRequest(server string, id string, body PostTocJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTocRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostTocRequestWithBody generates requests for PostToc with any type of body
func NewPostTocRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/sessions/%s/tocs", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenerateTotpRequest calls the generic GenerateTotp builder with application/json body
func NewGenerateTotpRequest(server string, id string, body GenerateTotpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateTotpRequestWithBody(server, id, "application/json", bodyReader)
}

// NewGenerateTotpRequestWithBody generates requests for GenerateTotp with any type of body
func NewGenerateTotpRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/sessions/%s/totp", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	req = req.WithContext(ctx)
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CreateSession request  with any body
	CreateSessionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateSessionResponse, error)

	CreateSessionWithResponse(ctx context.Context, body CreateSessionJSONRequestBody) (*CreateSessionResponse, error)

	// GetSession request
	GetSessionWithResponse(ctx context.Context, id string) (*GetSessionResponse, error)

	// PostToc request  with any body
	PostTocWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PostTocResponse, error)

	PostTocWithResponse(ctx context.Context, id string, body PostTocJSONRequestBody) (*PostTocResponse, error)

	// GenerateTotp request  with any body
	GenerateTotpWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*GenerateTotpResponse, error)

	GenerateTotpWithResponse(ctx context.Context, id string, body GenerateTotpJSONRequestBody) (*GenerateTotpResponse, error)
}

type CreateSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SessionCredentials
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Session
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTocResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostTocResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTocResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateTotpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OracleResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GenerateTotpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateTotpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CreateSessionWithBodyWithResponse request with arbitrary body returning *CreateSessionResponse
func (c *ClientWithResponses) CreateSessionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateSessionResponse, error) {
	rsp, err := c.CreateSessionWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateSessionResponse(rsp)
}

func (c *ClientWithResponses) CreateSessionWithResponse(ctx context.Context, body CreateSessionJSONRequestBody) (*CreateSessionResponse, error) {
	rsp, err := c.CreateSession(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateSessionResponse(rsp)
}

// GetSessionWithResponse request returning *GetSessionResponse
func (c *ClientWithResponses) GetSessionWithResponse(ctx context.Context, id string) (*GetSessionResponse, error) {
	rsp, err := c.GetSession(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseGetSessionResponse(rsp)
}

// PostTocWithBodyWithResponse request with arbitrary body returning *PostTocResponse
func (c *ClientWithResponses) PostTocWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PostTocResponse, error) {
	rsp, err := c.PostTocWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePostTocResponse(rsp)
}

func (c *ClientWithResponses) PostTocWithResponse(ctx context.Context, id string, body PostTocJSONRequestBody) (*PostTocResponse, error) {
	rsp, err := c.PostToc(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParsePostTocResponse(rsp)
}

// GenerateTotpWithBodyWithResponse request with arbitrary body returning *GenerateTotpResponse
func (c *ClientWithResponses) GenerateTotpWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*GenerateTotpResponse, error) {
	rsp, err := c.GenerateTotpWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseGenerateTotpResponse(rsp)
}

func (c *ClientWithResponses) GenerateTotpWithResponse(ctx context.Context, id string, body GenerateTotpJSONRequestBody) (*GenerateTotpResponse, error) {
	rsp, err := c.GenerateTotp(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseGenerateTotpResponse(rsp)
}

// ParseCreateSessionResponse parses an HTTP response from a CreateSessionWithResponse call
func ParseCreateSessionResponse(rsp *http.Response) (*CreateSessionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SessionCredentials
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSessionResponse parses an HTTP response from a GetSessionWithResponse call
func ParseGetSessionResponse(rsp *http.Response) (*GetSessionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Session
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostTocResponse parses an HTTP response from a PostTocWithResponse call
func ParsePostTocResponse(rsp *http.Response) (*PostTocResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostTocResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGenerateTotpResponse parses an HTTP response from a GenerateTotpWithResponse call
func ParseGenerateTotpResponse(rsp *http.Response) (*GenerateTotpResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GenerateTotpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OracleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Start a new session
	// (POST /sessions)
	CreateSession(ctx echo.Context) error
	// Retrieve a session details by its ID
	// (GET /sessions/{id})
	GetSession(ctx echo.Context, id string) error
	// Join a new Toc to an existing session
	// (POST /sessions/{id}/tocs)
	PostToc(ctx echo.Context, id string) error
	// Close the session and generate the TOTP
	// (POST /sessions/{id}/totp)
	GenerateTotp(ctx echo.Context, id string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// CreateSession converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSession(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSession(ctx)
	return err
}

// GetSession converts echo context to params.
func (w *ServerInterfaceWrapper) GetSession(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSession(ctx, id)
	return err
}

// PostToc converts echo context to params.
func (w *ServerInterfaceWrapper) PostToc(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostToc(ctx, id)
	return err
}

// GenerateTotp converts echo context to params.
func (w *ServerInterfaceWrapper) GenerateTotp(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GenerateTotp(ctx, id)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/sessions", wrapper.CreateSession)
	router.GET(baseURL+"/sessions/:id", wrapper.GetSession)
	router.POST(baseURL+"/sessions/:id/tocs", wrapper.PostToc)
	router.POST(baseURL+"/sessions/:id/totp", wrapper.GenerateTotp)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
